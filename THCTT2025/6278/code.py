# GENERATED BY CHATGPT
import zipfile, io, os, hashlib

ROOT_ZIP = '6278.zip'

# Utility: check if bytes look like a zip file
def bytes_are_zip(data: bytes) -> bool:
    return len(data) >= 4 and data[:2] == b'PK'


def try_decode_text(b: bytes):
    for enc in ('utf-8', 'latin-1', 'utf-16', 'utf-8-sig'):
        try:
            return b.decode(enc)
        except Exception:
            continue
    return None

result = {
    'found': False,
    'path_chain': [],
    'file_name': None,
    'depth': 0,
    'content_text': None,
    'content_len': 0,
}

if not os.path.exists(ROOT_ZIP):
    print(f"Error: {ROOT_ZIP} not found in current directory: {os.getcwd()}")
else:
    visited_archives = set()

    # Initialize stack with the outermost archive bytes
    with open(ROOT_ZIP, 'rb') as f:
        outer_bytes = f.read()

    stack = [(outer_bytes, [ROOT_ZIP])]

    while stack:
        zip_bytes, chain = stack.pop()
        h = hashlib.sha256(zip_bytes).hexdigest()
        if h in visited_archives:
            continue
        visited_archives.add(h)

        try:
            zf = zipfile.ZipFile(io.BytesIO(zip_bytes))
        except zipfile.BadZipFile:
            continue

        names = zf.namelist()
        # 1) Look for a filename containing 'flag'
        for name in names:
            if name.endswith('/'):
                continue
            if 'flag' in name.lower():
                data = zf.read(name)
                result['found'] = True
                result['path_chain'] = chain
                result['file_name'] = name
                result['depth'] = len(chain) - 1
                result['content_len'] = len(data)
                text = try_decode_text(data)
                if text is not None:
                    result['content_text'] = text
                stack.clear()
                break
        if result['found']:
            break

        # 2) Push inner zips onto the stack (depth-first)
        # Prefer entries named like .zip, but also detect by signature
        candidates = []
        for name in names:
            if name.endswith('/'):
                continue
            data = zf.read(name)
            if name.lower().endswith('.zip') or bytes_are_zip(data):
                candidates.append((data, chain + [name]))
        # Add candidates to stack for DFS
        stack.extend(candidates)

    if result['found']:
        print('Found flag file!')
        print('Depth:', result['depth'])
        print('Total chain length:', len(result['path_chain']))
        # To avoid an extremely long print, show first and last 3 elements of the chain
        chain = result['path_chain']
        if len(chain) > 8:
            preview = chain[:3] + ['...'] + chain[-3:]
            print('Path chain preview (outer -> inner):')
            print(' -> '.join(preview))
        else:
            print('Path chain (outer -> inner):')
            print(' -> '.join(chain))
        print('File name:', result['file_name'])
        if result['content_text'] is not None:
            print('--- Begin file contents ---')
            text = result['content_text']
            if len(text) > 8000:
                print(text[:8000])
                print('\n[truncated]')
            else:
                print(text)
            print('--- End file contents ---')
        else:
            print(f'Binary content length: {result["content_len"]} bytes (not displayed)')
    else:
        print('No file with name containing "flag" was found in the nested archives.')
